# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import typing
import symbolica.core
from enum import Enum

class CompiledTensorEvaluator:
    r"""
    A compiled and optimized evaluator for tensors.
    """
    def evaluate_complex(self, inputs:typing.Sequence[typing.Sequence[builtins.complex]]) -> builtins.list[Tensor]:
        r"""
        Evaluate the expression for multiple inputs and return the results.
        """

class LibraryTensor:
    r"""
    A tensor class that can be either dense or sparse.
    The data is either float or complex or a symbolica expression
    It can be instantiated with data using the `sparse_empty` or `dense` module functions.
    """
    def structure(self) -> TensorStructure: ...
    @staticmethod
    def sparse(structure:TensorStructure | builtins.list[Representation] | builtins.list[builtins.int], type_info:type) -> LibraryTensor:
        r"""
        Create a new sparse empty tensor with the given structure and type.
        The type is either a float or a symbolica expression.
        """
    @staticmethod
    def dense(structure:TensorStructure | builtins.list[Representation] | builtins.list[builtins.int], data:typing.Any) -> LibraryTensor:
        r"""
        Create a new dense tensor with the given structure and data.
        The structure can be a list of integers, a list of representations, or a list of slots.
        In the first two cases, no "indices" are assumed, and thus the tensor is indexless (i.e.) it has a shape but no proper way to contract it.
        The structure can also be a proper `TensorIndices` object or `TensorStructure` object.
        
        The data is either a list of floats or a list of symbolica expressions, of length equal to the number of elements in the structure, in row-major order.
        """
    @staticmethod
    def one() -> LibraryTensor: ...
    @staticmethod
    def zero() -> LibraryTensor: ...
    def to_dense(self) -> None: ...
    def to_sparse(self) -> None: ...
    def __repr__(self) -> builtins.str: ...
    def __str__(self) -> builtins.str: ...
    def __len__(self) -> builtins.int: ...
    def __getitem__(self, item:builtins.slice | builtins.int | builtins.list[builtins.int]) -> typing.Any: ...
    def __setitem__(self, item:typing.Any, value:typing.Any) -> None: ...
    def scalar(self) -> Expression: ...

class Representation:
    r"""
    A representation class in the sense of representation theory. This class is used to represent the representation of a tensor. It is essentially a pair of a name and a dimension.
    New representations are registered when constructing.
    Some representations are dualizable, meaning that they have a dual representation.
    Indices will only ever match across dual representations.
    There are some already registered representations, such as:
     EUCLIDEAN: Rep = Rep::SelfDual(0);
     BISPINOR: Rep = Rep::SelfDual(1);
     COLORADJ: Rep = Rep::SelfDual(2);
     MINKOWSKI: Rep = Rep::SelfDual(3);
    
     LORENTZ_UP: Rep = Rep::Dualizable(1);
     LORENTZ_DOWN: Rep = Rep::Dualizable(-1);
     SPINFUND: Rep = Rep::Dualizable(2);
     SPINANTIFUND: Rep = Rep::Dualizable(-2);
     COLORFUND: Rep = Rep::Dualizable(3);
     COLORANTIFUND: Rep = Rep::Dualizable(-3);
     COLORSEXT: Rep = Rep::Dualizable(4);
     COLORANTISEXT: Rep = Rep::Dualizable(-4);
    """
    def __new__(cls, name:typing.Any, dimension:builtins.int | Expression | str, is_self_dual:builtins.bool=True) -> Representation:
        r"""
        Register a new representation with the given name and dimension. If dual is true, the representation will be dualizable, else it will be self-dual.
        """
    def __call__(self, aind:builtins.int | Expression | str) -> typing.Any:
        r"""
        Generate a new slot with the given index, from this representation
        """
    def g(self, i:builtins.int | Expression | str, j:builtins.int | Expression | str) -> TensorIndices: ...
    def flat(self, i:builtins.int | Expression | str, j:builtins.int | Expression | str) -> TensorIndices: ...
    def id(self, i:builtins.int | Expression | str, j:builtins.int | Expression | str) -> TensorIndices: ...
    def __repr__(self) -> builtins.str: ...
    def __str__(self) -> builtins.str: ...
    def to_expression(self) -> Expression: ...
    @staticmethod
    def bis(dimension:builtins.int | Expression | str) -> Representation: ...
    @staticmethod
    def euc(dimension:builtins.int | Expression | str) -> Representation: ...
    @staticmethod
    def mink(dimension:builtins.int | Expression | str) -> Representation: ...

class Slot:
    r"""
    An abstract index slot for a tensor.
    This is essentially a tuple of a `Representation` and an abstract index id.
    
    The abstract index id can be either an integer or a symbol.
    This is the building block for creating tensor structures that can be contracted.
    """
    def __repr__(self) -> builtins.str: ...
    def __str__(self) -> builtins.str: ...
    def __new__(cls, name:typing.Any, dimension:builtins.int, aind:typing.Any, dual:builtins.bool=False) -> Slot:
        r"""
        Create a new slot from a name of a representation, a dimension and an abstract index.
         If dual is true, the representation will be dualizable, else it will be self-dual.
        """
    def to_expression(self) -> Expression: ...

class Tensor:
    r"""
    A tensor class that can be either dense or sparse.
    The data is either float or complex or a symbolica expression
    It can be instantiated with data using the `sparse_empty` or `dense` module functions.
    """
    def structure(self) -> TensorIndices: ...
    @staticmethod
    def sparse(structure:TensorIndices | builtins.list[Slot], type_info:type) -> Tensor:
        r"""
        Create a new sparse empty tensor with the given structure and type.
        The type is either a float or a symbolica expression.
        """
    @staticmethod
    def dense(structure:TensorIndices | builtins.list[Slot], data:typing.Any) -> Tensor:
        r"""
        Create a new dense tensor with the given structure and data.
        The structure can be a list of integers, a list of representations, or a list of slots.
        In the first two cases, no "indices" are assumed, and thus the tensor is indexless (i.e.) it has a shape but no proper way to contract it.
        The structure can also be a proper `TensorIndices` object or `TensorStructure` object.
        
        The data is either a list of floats or a list of symbolica expressions, of length equal to the number of elements in the structure, in row-major order.
        """
    @staticmethod
    def one() -> Tensor: ...
    @staticmethod
    def zero() -> Tensor: ...
    def to_dense(self) -> None: ...
    def to_sparse(self) -> None: ...
    def __repr__(self) -> builtins.str: ...
    def __str__(self) -> builtins.str: ...
    def __len__(self) -> builtins.int: ...
    def __getitem__(self, item:builtins.slice | builtins.int | builtins.list[builtins.int]) -> typing.Any: ...
    def __setitem__(self, item:typing.Any, value:typing.Any) -> None: ...
    def evaluator(self, constants:typing.Mapping[Expression, Expression], funs:typing.Mapping[tuple[Expression, builtins.str, typing.Sequence[Expression]], Expression], params:typing.Sequence[Expression], iterations:builtins.int=100, n_cores:builtins.int=4, verbose:builtins.bool=False) -> TensorEvaluator: ...
    def scalar(self) -> Expression: ...

class TensorEvaluator:
    r"""
    An optimized evaluator for tensors.
    """
    def evaluate(self, inputs:typing.Sequence[typing.Sequence[builtins.float]]) -> builtins.list[Tensor]:
        r"""
        Evaluate the expression for multiple inputs and return the results.
        """
    def evaluate_complex(self, inputs:typing.Sequence[typing.Sequence[builtins.complex]]) -> builtins.list[Tensor]:
        r"""
        Evaluate the expression for multiple inputs and return the results.
        """
    def compile(self, function_name:builtins.str, filename:builtins.str, library_name:builtins.str, inline_asm:builtins.str='default', optimization_level:builtins.int=3, compiler_path:typing.Optional[builtins.str]=None, custom_header:typing.Optional[builtins.str]=None) -> CompiledTensorEvaluator:
        r"""
        Compile the evaluator to a shared library using C++ and optionally inline assembly and load it.
        """

class TensorIndices:
    r"""
    A structure that can be used to represent the "shape" of a tensor, along with a list of abstract indices.
    This has an optional name, and accompanying symbolica expressions that are considered as additional non-indexed arguments.
    The structure is essentially a list of `Slots` that are used to define the structure of the tensor.
    """
    def __new__(cls, *additional_args, name:typing.Optional[TensorIndices | builtins.list[Slot]]=None) -> TensorIndices: ...
    def set_name(self, name:TensorIndices | builtins.list[Slot]) -> None: ...
    def get_name(self) -> typing.Optional[TensorName]: ...
    def __repr__(self) -> builtins.str: ...
    def __str__(self) -> builtins.str: ...
    def to_expression(self) -> Expression: ...
    def __len__(self) -> builtins.int: ...
    def __getitem__(self, item:builtins.slice | builtins.int | builtins.list[builtins.int]) -> typing.Any: ...
    def __add__(self, rhs:Expression | int | str | float | complex | TensorIndices | Expression) -> Expression:
        r"""
        Add this expression to `other`, returning the result.
        """
    def __radd__(self, rhs:Expression | int | str | float | complex | TensorIndices | Expression) -> Expression:
        r"""
        Add this expression to `other`, returning the result.
        """
    def __sub__(self, rhs:Expression | int | str | float | complex | TensorIndices | Expression) -> Expression:
        r"""
        Subtract `other` from this expression, returning the result.
        """
    def __rsub__(self, rhs:Expression | int | str | float | complex | TensorIndices | Expression) -> Expression:
        r"""
        Subtract this expression from `other`, returning the result.
        """
    def __mul__(self, rhs:Expression | int | str | float | complex | TensorIndices | Expression) -> Expression:
        r"""
        Add this expression to `other`, returning the result.
        """
    def __rmul__(self, rhs:Expression | int | str | float | complex | TensorIndices | Expression) -> Expression:
        r"""
        Add this expression to `other`, returning the result.
        """

class TensorLibrary:
    def __new__(cls) -> TensorLibrary: ...
    def register(self, tensor:Tensor | LibraryTensor) -> None: ...
    def __getitem__(self, key:Expression | int | str | float | complex | builtins.str) -> TensorStructure: ...
    @staticmethod
    def hep_lib() -> TensorLibrary: ...

class TensorName:
    r"""
    The name of a tensor.
    """
    g: TensorName
    flat: TensorName
    gamma: TensorName
    gamma5: TensorName
    projm: TensorName
    projp: TensorName
    sigma: TensorName
    f: TensorName
    t: TensorName
    def __new__(cls, name:builtins.str, is_symmetric:typing.Optional[builtins.bool]=None, is_antisymmetric:typing.Optional[builtins.bool]=None, is_cyclesymmetric:typing.Optional[builtins.bool]=None, is_linear:typing.Optional[builtins.bool]=None, custom_normalization:typing.Optional[Transformer]=None, custom_print:typing.Optional[typing.Any]=None) -> TensorName:
        r"""
        Shorthand notation for :func:`Expression.symbol`.
        """
    def __call__(self, *args) -> TensorStructure | TensorIndices: ...
    def __repr__(self) -> builtins.str: ...
    def __str__(self) -> builtins.str: ...
    def to_expression(self) -> Expression: ...

class TensorNetwork:
    r"""
    A tensor network.
    
    This class is a wrapper around the `TensorNetwork` class from the `spenso` crate.
    Such a network is a graph representing the arithmetic operations between tensors.
    In the most basic case, edges represent the contraction of indices.
    """
    ...

class TensorStructure:
    r"""
    A structure that can be used to represent the "shape" of a tensor.
    This has an optional name, and accompanying symbolica expressions that are considered as additional non-indexed arguments.
    The structure is essentially a list of `Representation` that are used to define the structure of the tensor.
    """
    def from_list(self, additional_args:tuple, name:typing.Optional[TensorIndices | builtins.list[Slot]]) -> TensorStructure: ...
    def set_name(self, name:TensorIndices | builtins.list[Slot]) -> None: ...
    def get_name(self) -> typing.Optional[TensorName]: ...
    def __repr__(self) -> builtins.str: ...
    def __str__(self) -> builtins.str: ...
    def __len__(self) -> builtins.int: ...
    def __getitem__(self, item:builtins.slice | builtins.int | builtins.list[builtins.int]) -> typing.Any: ...
    def __call__(self, args:tuple, extra_args:typing.Optional[list]) -> Expression:
        r"""
        Convenience method. Calls `symbolic(*args, extra_args=extra_args)`.
        
        Creates a symbolic `Expression` representing this tensor structure. See the
        `symbolic` method documentation for details on argument handling.
        """
    def symbolic(self, args:tuple, extra_args:typing.Optional[list]) -> Expression:
        r"""
        Creates a symbolic `Expression` representing this tensor structure with the given arguments.
        
        # Args:
            *args (int | str | Symbol | Expression | ';'): Positional arguments. Can include
                indices, expressions, or the semicolon separator.
            extra_args (list[Expression], optional): Explicit list of additional non-tensorial args.
        
        Interprets positional arguments (`*args`) as potential indices. Arguments
        before a semicolon separator (`;`) and arguments provided via the `extra_args`
        keyword argument are combined and treated as additional non-tensorial arguments.
        Arguments after the semicolon (or all positional arguments if no separator is used)
        are treated as the symbolic tensor indices.
        
        
        # Returns:
            Expression: A symbolic expression representing the tensor.
        
        # Raises:
            ValueError: If index count mismatches or separator is misused.
            TypeError: If arguments have unexpected types.
            RuntimeError: If the structure does not have a name.
        """
    def index(self, args:tuple, extra_args:typing.Optional[list], cook_indices:builtins.bool) -> TensorIndices:
        r"""
        Creates an indexed tensor instance (`TensorIndices`) from this structure.
        
        Interprets positional arguments (`*args`) as potential indices. Arguments
        before a semicolon separator (`;`) and arguments provided via the `extra_args`
        keyword argument are combined and treated as additional non-tensorial arguments.
        Arguments after the semicolon (or all positional arguments if no separator is used)
        are treated as the tensor indices.
        
        # Args:
            *args: Positional arguments. Can include indices (int, str, Symbol, Expression),
                   or a single semicolon string (`;`).
            extra_args (list[Expression], optional): An explicit list of additional non-tensorial
                arguments. Defaults to None.
            cook_indices (bool, optional): If True, attempt to "cook" non-index arguments
                intended as tensor indices into valid `AbstractIndex` representations.
                Defaults to False.
        
        # Returns:
            TensorIndices: An object representing the tensor structure with concrete indices assigned.
        
        # Raises:
            ValueError: If index resolution fails, counts mismatch, or separator is misused.
            TypeError: If arguments have unexpected types.
        """

class ExecutionMode(Enum):
    Single = ...
    Scalar = ...
    All = ...

class TensorNamespace(Enum):
    Weyl = ...
    Algebra = ...

