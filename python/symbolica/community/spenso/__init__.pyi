# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import typing
import symbolica.core
from enum import Enum
from symbolica.core import *

class CompiledTensorEvaluator:
    r"""
    A compiled and optimized evaluator for maximum performance tensor evaluation.

    This class wraps a compiled C++ shared library for extremely fast numerical
    evaluation of tensor expressions. It only supports complex-valued evaluation
    as this is the most general case.

    Create instances using the `TensorEvaluator.compile()` method.

    # Examples:
    ```python
    # Created from a TensorEvaluator
    compiled = evaluator.compile("eval_func", "code.cpp", "lib")

    # Use for high-performance evaluation
    results = compiled.evaluate_complex(large_input_batch)
    ```
    """
    def evaluate_complex(
        self, inputs: typing.Sequence[typing.Sequence[builtins.complex]]
    ) -> builtins.list[Tensor]:
        r"""
        Evaluate the tensor expression for multiple complex-valued parameter inputs.

        Uses the compiled C++ code for maximum performance evaluation with complex numbers.

        # Args:
            inputs: List of parameter value lists, where each inner list contains
                    complex values for all parameters in the same order as specified
                    when creating the original evaluator

        # Returns:
            List of evaluated tensors, one for each input parameter set

        # Examples:
        ```python
        import symbolica as sp
        from symbolica.community.spenso import Tensor

        # Use compiled evaluator for complex inputs
        complex_inputs = [
            [1.0+2.0j, 3.0+0.0j],  # x=1+2i, y=3
            [0.0+1.0j, 2.0+1.0j]   # x=i, y=2+i
        ]
        results = compiled_evaluator.evaluate_complex(complex_inputs)
        ```
        """

class LibraryTensor:
    r"""
    A library tensor class optimized for use in tensor libraries and networks.

    Library tensors are similar to regular tensors but use explicit keys for efficient
    lookup and storage in tensor libraries. They can be either dense or sparse and
    store data as floats, complex numbers, or symbolic expressions.

    LibraryTensors are designed for:
    - Registration in TensorLibrary instances
    - Use in tensor networks where structure reuse is important
    - Efficient symbolic manipulation and pattern matching

    # Examples:
    ```python
    from symbolica.community.spenso import (
        LibraryTensor,
        TensorStructure,
        Representation,
    )

    # Create a structure for a color matrix
    rep = Representation.euc(3)  # 3x3 color fundamental
    structure = TensorStructure(rep, rep, name="T")
    # Create dense library tensor
    data = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0]  # Identity matrix
    tensor = LibraryTensor.dense(structure, data)
    # Create sparse library tensor
    sparse_tensor = LibraryTensor.sparse(structure, float)

    ```
    """
    @typing.overload
    def __getitem__(
        self, item: builtins.slice
    ) -> builtins.list[Expression | builtins.complex | float]:
        r"""
        Get library tensor elements at the specified range of indices.

        # Args:
            item: Index specification:
                - slice: Slice object defining the range of indices

        # Returns:
            The tensor element(s) at the specified index:
                - list of complex or float
                - list of Expressions
        """
    @typing.overload
    def __getitem__(
        self, item: typing.Sequence[builtins.int] | builtins.int
    ) -> Expression | builtins.complex | float:
        r"""
        Get library tensor element at the specified index or indices.

        # Args:
            item: Index specification:
                - int: Flat index into the tensor
                - List[int]: Multi-dimensional index coordinates

        # Returns:
            The tensor element(s) at the specified index:
                - complex or float: Numerical value
                - Expression: Symbolic expression
        """
    @typing.overload
    def __getitem__(
        self, item: builtins.slice | builtins.int | builtins.list[builtins.int]
    ) -> typing.Any: ...
    @typing.overload
    def __setitem__(
        self,
        item: typing.Sequence[builtins.int] | builtins.int,
        value: Expression | builtins.complex | float,
    ) -> None:
        r"""
        Set library tensor element(s) at the specified index or indices.

        # Args:
            item: Index specification:
                - int: Flat index into the tensor
                - List[int]: Multi-dimensional index coordinates
            value: The value to set:
                - float: Numerical value
                - Expression: Symbolic expression

        # Examples:
        ```python
        from symbolica.community.spenso import LibraryTensor, TensorStructure, Representation

        rep = Representation.euc(2)
        structure = TensorStructure(rep, rep)
        tensor = LibraryTensor.sparse(structure, float)

        # Set using flat index
        tensor[0] = 1.0

        # Set using coordinates
        tensor[1, 1] = 2.0
        ```
        """
    @typing.overload
    def __setitem__(self, item: typing.Any, value: typing.Any) -> None:
        r"""
        Set library tensor element(s) at the specified index or indices.

        # Args:
            item: Index specification:
                - int: Flat index into the tensor
                - List[int]: Multi-dimensional index coordinates
            value: The value to set:
                - float: Numerical value
                - Expression: Symbolic expression

        # Examples:
        ```python
        from symbolica.community.spenso import LibraryTensor, TensorStructure, Representation

        rep = Representation.euc(2)
        structure = TensorStructure(rep, rep)
        tensor = LibraryTensor.sparse(structure, float)

        # Set using flat index
        tensor[0] = 1.0

        # Set using coordinates
        tensor[1, 1] = 2.0
        ```
        """
    def structure(self) -> TensorStructure: ...
    @staticmethod
    def sparse(
        structure: TensorStructure
        | builtins.list[Representation]
        | builtins.list[builtins.int],
        type_info: type,
    ) -> LibraryTensor:
        r"""
        Create a new sparse empty library tensor with the given structure and data type.

        Creates a sparse tensor that initially contains no non-zero elements.
        Elements can be set individually using indexing operations.

        # Args:
            structure: The tensor structure (TensorStructure, list of Representations, or list of integers)
            type_info: The data type - either `float` or `Expression` class

        # Returns:
            A new sparse library tensor with all elements initially zero

        # Examples:
        ```python
        import symbolica as sp
        from symbolica.community.spenso import (
            LibraryTensor,
            TensorStructure,
            Representation,
        )

        # Create structure from representations
        rep = Representation.euc(3)
        structure = TensorStructure(rep, rep)
        # Create sparse float tensor
        sparse_float = LibraryTensor.sparse(structure, float)
        # Create sparse symbolic tensor
        sparse_sym = LibraryTensor.sparse(structure, sp.Expression)
        # Set individual elements
        sparse_float[0, 0] = 1.0
        sparse_float[1, 1] = 2.0
        print(sparse_float)

        ```
        """
    @staticmethod
    def dense(
        structure: TensorStructure
        | builtins.list[Representation]
        | builtins.list[builtins.int],
        data: typing.Sequence[Expression]
        | typing.Sequence[builtins.float]
        | typing.Sequence[builtins.complex],
    ) -> LibraryTensor:
        r"""
        Create a new dense library tensor with the given structure and data.

        Dense tensors store all elements explicitly in row-major order. The structure
        defines the tensor's shape and indexing properties.

        # Args:
            structure: The tensor structure, can be:
                - TensorStructure object (proper library structure)
                - List of Representations (creates library structure)
                - List of integers (creates indexless shape)
            data: The tensor data in row-major order:
                - List of floats for numerical tensors
                - List of Expressions for symbolic tensors

        # Returns:
            A new dense library tensor with the specified data

        # Examples:
        ```python
        from symbolica import S
        from symbolica.community.spenso import (
            LibraryTensor,
            TensorStructure,
            Representation,
        )

        # Create a 2x2 color matrix
        rep = Representation.euc(2)
        sigma = S("sigma")
        structure = TensorStructure(rep, rep, name=sigma)
        data = [0.0, 1.0, 1.0, 0.0]  # Pauli matrix σ_x
        tensor = LibraryTensor.dense(structure, data)
        # Create symbolic tensor
        x, y = S("x", "y")
        sym_data = [x, y, -y, x]  # 2x2 matrix with symbolic entries
        sym_tensor = LibraryTensor.dense(structure, sym_data)
        print(sym_tensor)

        ```
        """
    @staticmethod
    def one() -> LibraryTensor:
        r"""
        Create a scalar library tensor with value 1.0.

        # Returns:
            A scalar library tensor containing the value 1.0

        # Examples:
        ```python
        from symbolica.community.spenso import LibraryTensor

        one = LibraryTensor.one()
        print(one)  # Scalar library tensor with value 1.0
        ```
        """
    @staticmethod
    def zero() -> LibraryTensor:
        r"""
        Create a scalar library tensor with value 0.0.

        # Returns:
            A scalar library tensor containing the value 0.0

        # Examples:
        ```python
        from symbolica.community.spenso import LibraryTensor

        zero = LibraryTensor.zero()
        print(zero)  # Scalar library tensor with value 0.0
        ```
        """
    def to_dense(self) -> None:
        r"""
        Convert this library tensor to dense storage format.

        Converts sparse tensors to dense format in-place. Dense tensors are unchanged.
        This allocates memory for all tensor elements.

        # Examples:
        ```python
        from symbolica.community.spenso import LibraryTensor, TensorStructure, Representation

        rep = Representation.cof(2)
        structure = TensorStructure([rep, rep])
        tensor = LibraryTensor.sparse(structure, float)
        tensor[0, 0] = 1.0
        tensor.to_dense()  # Now stores all 4 elements explicitly
        ```
        """
    def to_sparse(self) -> None:
        r"""
        Convert this library tensor to sparse storage format.

        Converts dense tensors to sparse format in-place, only storing non-zero elements.
        This can save memory for tensors with many zero elements.

        # Examples:
        ```python
        from symbolica.community.spenso import LibraryTensor, TensorStructure, Representation

        rep = Representation.euc(2)
        structure = TensorStructure(rep, rep)
        data = [1.0, 0.0, 0.0, 2.0]
        tensor = LibraryTensor.dense(structure, data)
        tensor.to_sparse()  # Now only stores 2 non-zero elements
        ```
        """
    def __repr__(self) -> builtins.str: ...
    def __str__(self) -> builtins.str: ...
    def __len__(self) -> builtins.int: ...
    def scalar(self) -> Expression:
        r"""
        Extract the scalar value from a rank-0 (scalar) library tensor.

        # Returns:
            The scalar expression contained in this tensor

        # Raises:
            RuntimeError: If the tensor is not a scalar

        # Examples:
        ```python
        from symbolica.community.spenso import LibraryTensor

        scalar_tensor = LibraryTensor.one()
        value = scalar_tensor.scalar()  # Returns expression "1"
        ```
        """

class Representation:
    r"""
    A representation in the sense of group representation theory for tensor indices.

    Representations define the transformation properties of tensor indices under group operations.
    They specify the dimension and duality structure, determining which indices can contract.

    Key concepts:
    - **Self-dual**: Indices can contract with other indices of the same representation
    - **Dualizable**: Indices can only contract with their dual representation
    - **Dimension**: Size of the representation space

    # Predefined Representations:
    Common physics representations are available as class methods:
    - `Representation.euc(d)`: Euclidean space (self-dual)
    - `Representation.mink(d)`: Minkowski space (self-dual)
    - `Representation.bis(d)`: Bispinor (self-dual)
    - `Representation.cof(d)`: Color fundamental (dualizable)
    - `Representation.coad(d)`: Color adjoint (self-dual)
    - `Representation.cos(d)`: Color sextet (dualizable)

    # Examples:
    ```python
    from symbolica.community.spenso import Representation

    # Standard representations
    euclidean = Representation.euc(4)      # 4D Euclidean
    lorentz = Representation.mink(4)       # 4D Minkowski
    color = Representation.cof(3)          # SU(3) fundamental
    adjoint = Representation.coad(8)       # SU(3) adjoint

    # Custom representation
    custom = Representation("MyRep", 5, is_self_dual=True)

    # Create slots with indices
    mu_slot = euclidean('mu')              # Euclidean index μ
    a_slot = color('a')                    # Color index a

    # Generate metric tensors
    metric = euclidean.g('mu', 'nu')       # g_μν
    ```
    """
    @typing.overload
    def __call__(self, aind: builtins.int | Expression | str) -> Slot:
        r"""
        Create a slot from this representation, by specifying an index

        # Args:
        aind: The index specification:
            - Abstract index (int, str, Symbol)

        # Returns:
            Slot
        # Examples:
        ```python
        from symbolica.community.spenso import Representation
        import symbolica as sp

        rep = Representation.euc(3)

        # Create slots with different index types
        slot1 = rep('mu')        # String index
        slot2 = rep(1)           # Integer index
        slot3 = rep(sp.S('nu'))  # Symbolic index
        ```
        """
    @typing.overload
    def __call__(self, aind: Expression) -> Expression | Slot:
        r"""
        Create a slot or symbolic expression from this representation.

        # Args:
        aind: The index specification:
            Expression: Creates symbolic representation

        # Returns:
            Expression

        # Examples:
        ```python
        from symbolica.community.spenso import Representation
        import symbolica as sp

        rep = Representation.euc(3)

        expr = rep(sp.E("cos(x)"))
        ```
        """
    def __new__(
        cls,
        name: builtins.str,
        dimension: builtins.int | Expression | str,
        is_self_dual: builtins.bool = True,
    ) -> Representation:
        r"""
        Create and register a new representation with specified properties.

        # Args:
            name: String name for the representation
            dimension: Size of the representation (int or symbolic)
            is_self_dual: If True, creates self-dual representation; if False, creates dualizable pair

        # Returns:
            A new Representation object

        # Examples:
        ```python
        from symbolica.community.spenso import Representation
        import symbolica as sp

        # Self-dual representation (indices contract with themselves)
        euclidean = Representation("Euclidean", 4, is_self_dual=True)

        # Dualizable representation (needs dual partner for contraction)
        vector_up = Representation("VectorUp", 4, is_self_dual=False)

        vector_down =vector_up.dual()  # Get dual representation
        # Symbolic dimension
        n = sp.S('n')
        general = Representation("General", n, is_self_dual=True)
        ```
        """
    def g(
        self,
        i: builtins.int | Expression | str,
        j: builtins.int | Expression | str,
    ) -> TensorIndices:
        r"""
        Create a metric tensor for this representation.

        # Args:
            i: First index
            j: Second index

        # Returns:
            TensorIndices representing the metric tensor g_ij

        # Examples:
        ```python
        rep = Representation.mink(4)
        metric = rep.g('mu', 'nu')  # Minkowski metric g_μν
        ```
        """
    def flat(
        self,
        i: builtins.int | Expression | str,
        j: builtins.int | Expression | str,
    ) -> TensorIndices:
        r"""
        Create a musical isomorphism tensor for this representation.

        # Args:
            i: First index
            j: Second index

        # Returns:
            TensorIndices representing the flat musical isomorphism tensor ♭_ij

        # Examples:
        ```python
        rep = Representation.mink(4)
        flat = rep.flat('mu', 'nu')  # Flat isomorphism ♭_μν
        ```
        """
    def id(
        self,
        i: builtins.int | Expression | str,
        j: builtins.int | Expression | str,
    ) -> TensorIndices:
        r"""
        Create an identity tensor for this representation.

        # Args:
            i: First index
            j: Second index

        # Returns:
            TensorIndices representing the identity tensor δ_ij

        # Examples:
        ```python
        rep = Representation.cof(3)
        identity = rep.id('a', 'b')  # Color identity δ_ab
        ```
        """
    def __repr__(self) -> builtins.str: ...
    def __str__(self) -> builtins.str: ...
    def to_expression(self) -> Expression:
        r"""
        Convert the representation to a symbolic expression.

        # Returns:
            A symbolic Expression representing this representation
        """
    @staticmethod
    def bis(dimension: builtins.int | Expression | str) -> Representation:
        r"""
        Create a bispinor representation.

        # Args:
            dimension: The dimension of the bispinor space

        # Returns:
            A bispinor Representation
        """
    @staticmethod
    def euc(dimension: builtins.int | Expression | str) -> Representation:
        r"""
        Create a Euclidean space representation.

        # Args:
            dimension: The dimension of the Euclidean space

        # Returns:
            A Euclidean Representation
        """
    @staticmethod
    def mink(dimension: builtins.int | Expression | str) -> Representation:
        r"""
        Create a Minkowski space representation.

        # Args:
            dimension: The dimension of the Minkowski space

        # Returns:
            A Minkowski Representation
        """
    @staticmethod
    def cof(dimension: builtins.int | Expression | str) -> Representation:
        r"""
        Create a color fundamental representation.

        # Args:
            dimension: The dimension of the color group (e.g., 3 for SU(3))

        # Returns:
            A color fundamental Representation
        """
    @staticmethod
    def coad(dimension: builtins.int | Expression | str) -> Representation:
        r"""
        Create a color adjoint representation.

        # Args:
            dimension: The dimension of the adjoint representation (e.g., 8 for SU(3))

        # Returns:
            A color adjoint Representation
        """
    @staticmethod
    def cos(dimension: builtins.int | Expression | str) -> Representation:
        r"""
        Create a color sextet representation.

        # Args:
            dimension: The dimension of the sextet representation (e.g., 6 for SU(3))

        # Returns:
            A color sextet Representation
        """

class Slot:
    r"""
    A tensor index slot combining a representation with an abstract index.

    Slots are the building blocks for tensor structures, pairing a representation
    (which defines transformation properties) with an abstract index identifier.
    Slots with matching representations and indices can be contracted.

    # Examples:
    ```python
    from symbolica.community.spenso import Slot, Representation
    import symbolica as sp

    # Create representation and slots
    rep = Representation.euc(3)
    slot1 = rep('mu')           # Slot with string index
    slot2 = rep(1)              # Slot with integer index
    slot3 = rep(sp.S('nu')) # Slot with symbolic index

    # Create custom slot
    custom_slot = Slot("MyRep", 4, 'alpha', dual=False)

    # Use in tensor structures
    from symbolica.community.spenso import TensorIndices
    tensor_structure = TensorIndices(slot1, slot2)
    ```
    """
    def __repr__(self) -> builtins.str: ...
    def __str__(self) -> builtins.str: ...
    def __new__(
        cls,
        name: builtins.str,
        dimension: builtins.int,
        aind: builtins.int | Expression | str,
        dual: builtins.bool = False,
    ) -> Slot:
        r"""
        Create a new slot with a custom representation and index.

        # Args:
            name: String name for the representation
            dimension: Size of the representation space
            aind: The abstract index (int, str, or Symbol)
            dual: If True, creates dualizable representation; if False, self-dual

        # Returns:
            A new Slot object

        # Examples:
        ```python
        from symbolica.community.spenso import Slot
        import symbolica as sp

        # Self-dual slot
        euclidean_slot = Slot("Euclidean", 4, 'mu', dual=False)

        # Dualizable slot
        vector_slot = Slot("Vector", 4, 'nu', dual=True)

        # With symbolic index
        sym_index = sp.S('alpha')
        symbolic_slot = Slot("Custom", 3, sym_index, dual=False)
        ```
        """
    def to_expression(self) -> Expression:
        r"""
        Convert the slot to a symbolic expression.

        # Returns:
            A symbolic Expression representing this slot

        # Examples:
        ```python
        rep = Representation.euc(3)
        slot = rep('mu')
        expr = slot.to_expression()  # Symbolic representation of the slot
        ```
        """

class Tensor:
    r"""
    A tensor class that can be either dense or sparse with flexible data types.

    The tensor can store data as floats, complex numbers, or symbolic expressions (Symbolica atoms).
    Tensors have an associated structure that defines their shape and index properties.

    # Examples
    ```python
    from symbolica.community.spenso import (
        Tensor,
        TensorIndices,
        Representation,
    )
    # Create a structure for a 2x2 matrix
    structure = TensorIndices(Representation.euc(4)(1))  # 4 elements total
    # Create a dense tensor with float data
    data = [1.0, 2.0, 3.0, 4.0]
    tensor = Tensor.dense(structure, data)
    # Create a sparse tensor
    sparse_tensor = Tensor.sparse(structure, float)
    ```
    """
    @typing.overload
    def __getitem__(
        self, item: builtins.slice
    ) -> builtins.list[Expression | builtins.complex | float]:
        r"""
        Get tensor elements at the specified range of indices.

        # Args:
            item: Index specification:
                - slice: Slice object defining the range of indices

        # Returns:
            The tensor element(s) at the specified index:
                - list of complex or float
                - list of Expressions
        """
    @typing.overload
    def __getitem__(
        self, item: typing.Sequence[builtins.int] | builtins.int
    ) -> Expression | builtins.complex | float:
        r"""
        Get tensor element at the specified index or indices.

        # Args:
            item: Index specification:
                - int: Flat index into the tensor
                - List[int]: Multi-dimensional index coordinates

        # Returns:
            The tensor element(s) at the specified index:
                - complex or float: Numerical value
                - Expression: Symbolic expression
        """
    @typing.overload
    def __getitem__(
        self, item: builtins.slice | builtins.int | builtins.list[builtins.int]
    ) -> typing.Any: ...
    @typing.overload
    def __setitem__(
        self,
        item: typing.Sequence[builtins.int] | builtins.int,
        value: Expression | builtins.complex | float,
    ) -> None:
        r"""
        Set tensor element at the specified index.

        # Args:
            item: Index specification:
                - int: Flat index into the tensor
                - List[int]: Multi-dimensional index coordinates
            value: The value to set:
                - float: Numerical value
                - Expression: Symbolic expression

        # Examples:
        ```python
        from symbolica.community.spenso import LibraryTensor, TensorStructure, Representation

        rep = Representation.euc(2)
        structure = TensorStructure(rep, rep)
        tensor = LibraryTensor.sparse(structure, float)

        # Set using flat index
        tensor[0] = 1.0

        # Set using coordinates
        tensor[1, 1] = 2.0
        ```
        """
    @typing.overload
    def __setitem__(self, item: typing.Any, value: typing.Any) -> None:
        r"""
        Set tensor element(s) at the specified index or indices.

        # Args:
            item: Index specification:
                - int: Flat index into the tensor
                - List[int]: Multi-dimensional index coordinates
            value: The value to set:
                - float: Numerical value
                - Expression: Symbolic expression

        # Examples:
        ```python
        from symbolica.community.spenso import (
            Tensor,
            TensorIndices,
            Representation as R,
        )
        structure = TensorIndices(R.euc(2)(2), R.euc(2)(1))
        data = [1.0, 0.0, 0.0, 2.0]
        tensor = Tensor.dense(structure, data)
        tensor.to_sparse()  # Now only stores 2 non-zero elements
        print(tensor)
        tensor = Tensor.sparse(structure, float)
        # Set using flat index
        tensor[0] = 4.0
        # Set using coordinates
        tensor[1, 1] = 1.0
        print(tensor)
        ```
        """
    def structure(self) -> TensorIndices: ...
    @staticmethod
    def sparse(
        structure: TensorIndices | builtins.list[Slot], type_info: type
    ) -> Tensor:
        r"""
        Create a new sparse empty tensor with the given structure and data type.

        # Args:
            structure: The tensor structure (TensorIndices or list of Slots)
            type_info: The data type - either `float` or `Expression` class

        # Returns:
            A new sparse tensor with all elements initially zero

        # Examples:
        ```python
        from symbolica.community.spenso import Tensor, TensorIndices,Representation as R

        # Create structure
        structure = TensorIndices(R.euc(3)(1), R.euc(3)(2))  # 3x3 tensor

        # Create sparse float tensor
        sparse_float = Tensor.sparse(structure, float)

        # Create sparse symbolic tensor
        sparse_sym = Tensor.sparse(structure, symbolica.Expression)
        ```
        """
    @staticmethod
    def dense(
        structure: TensorIndices | builtins.list[Slot],
        data: typing.Sequence[Expression]
        | typing.Sequence[builtins.float]
        | typing.Sequence[builtins.complex],
    ) -> Tensor:
        r"""
        Create a new dense tensor with the given structure and data.

        # Args:
            structure: The tensor structure (TensorIndices or list of Slots)
            data: The tensor data in row-major order:
                - List of floats for numerical tensors
                - List of Expressions for symbolic tensors

        # Returns:
            A new dense tensor with the specified data

        # Examples:
        ```python
        import symbolica as sp
        from symbolica import S
        from symbolica.community.spenso import (
            Tensor,
            TensorIndices,
            Representation as R,
        )
        # Create a 2x2 matrix
        structure = TensorIndices(R.euc(2)(1), R.euc(2)(2))
        data = [1.0, 2.0, 3.0, 4.0]  # [[1,2], [3,4]]
        tensor = Tensor.dense(structure, data)
        # Create symbolic tensor
        x, y = S("x", "y")
        sym_data = [x, y, x * y, x + y]
        sym_tensor = Tensor.dense(structure, sym_data)
        print(tensor)
        print(sym_tensor)
        ```
        """
    @staticmethod
    def one() -> Tensor:
        r"""
        Create a scalar tensor with value 1.0.

        # Returns:
            A scalar tensor containing the value 1.0

        # Examples:
        ```python
        from symbolica.community.spenso import Tensor

        one = Tensor.one()
        print(one)  # Scalar tensor with value 1.0
        ```
        """
    @staticmethod
    def zero() -> Tensor:
        r"""
        Create a scalar tensor with value 0.0.

        # Returns:
            A scalar tensor containing the value 0.0

        # Examples:
        ```python
        from symbolica.community.spenso import Tensor

        zero = Tensor.zero()
        print(zero)  # Scalar tensor with value 0.0
        ```
        """
    def to_dense(self) -> None:
        r"""
        Convert this tensor to dense storage format.

        Converts sparse tensors to dense format in-place. Dense tensors are unchanged.
        This allocates memory for all tensor elements.

        # Examples:
        ```python
        from symbolica.community.spenso import Tensor, TensorIndices,Representation as R

        structure = TensorIndices(R.euc(4)(2))
        tensor = Tensor.sparse(structure, float)
        tensor[0] = 1.0
        tensor.to_dense()  # Now stores all 4 elements explicitly
        ```
        """
    def to_sparse(self) -> None:
        r"""
        Convert this tensor to sparse storage format.

        Converts dense tensors to sparse format in-place, only storing non-zero elements.
        This can save memory for tensors with many zero elements.

        # Examples:
        ```python
        from symbolica.community.spenso import Tensor, TensorIndices,Representation as R

        structure = TensorIndices(R.euc(2)(2),R.euc(2)(1))
        data = [1.0, 0.0, 0.0, 2.0]
        tensor = Tensor.dense(structure, data)
        tensor.to_sparse()  # Now only stores 2 non-zero elements
        print(tensor)
        ```
        """
    def __repr__(self) -> builtins.str: ...
    def __str__(self) -> builtins.str: ...
    def __len__(self) -> builtins.int: ...
    def evaluator(
        self,
        constants: typing.Mapping[Expression, Expression],
        funs: typing.Mapping[
            tuple[Expression, builtins.str, typing.Sequence[Expression]],
            Expression,
        ],
        params: typing.Sequence[Expression],
        iterations: builtins.int = 100,
        n_cores: builtins.int = 4,
        verbose: builtins.bool = False,
    ) -> TensorEvaluator:
        r"""
        Create an optimized evaluator for symbolic tensor expressions.

        Compiles the symbolic expressions in this tensor into an optimized evaluation tree
        that can efficiently compute numerical values for different parameter inputs.

        # Args:
            constants: Dict mapping symbolic expressions to their constant numerical values
            funs: Dict mapping function signatures to their symbolic definitions
            params: List of symbolic parameters that will be varied during evaluation
            iterations: Number of optimization iterations for Horner scheme (default: 100)
            n_cores: Number of CPU cores to use for optimization (default: 4)
            verbose: Whether to print optimization progress (default: False)

        # Returns:
            A TensorEvaluator object for efficient numerical evaluation

        # Examples:
        ```python
        from symbolica import S
        from symbolica.community.spenso import (
            Tensor,
            TensorIndices,
            Representation as R,
        )
        # Create symbolic tensor
        x, y = S("x", "y")
        structure = TensorIndices(R.euc(2)(1))
        tensor = Tensor.dense(structure, [x * y, x + y])
        # Create evaluator
        evaluator = tensor.evaluator(
            constants={}, funs={}, params=[x, y], iterations=50
        )
        # Use evaluator
        results = evaluator.evaluate_complex([[1.0, 2.0], [3.0, 4.0]])
        print(results)
        ```
        """
    def scalar(self) -> Expression:
        r"""
        Extract the scalar value from a rank-0 (scalar) tensor.

        # Returns:
            The scalar expression contained in this tensor

        # Raises:
            RuntimeError: If the tensor is not a scalar

        # Examples:
        ```python
        from symbolica.community.spenso import Tensor

        scalar_tensor = Tensor.one()
        value = scalar_tensor.scalar()  # Returns expression "1"
        ```
        """

class TensorEvaluator:
    r"""
    An optimized evaluator for symbolic tensor expressions.

    This class provides efficient numerical evaluation of symbolic tensor expressions
    after optimization. It supports both real and complex-valued evaluations.

    Create instances using the `Tensor.evaluator()` method rather than directly.

    # Examples:
    ```python
    # Created from a symbolic tensor
    evaluator = my_tensor.evaluator(constants={}, funs={}, params=[x, y])

    # Evaluate for multiple parameter sets
    results = evaluator.evaluate([[1.0, 2.0], [3.0, 4.0]])
    ```
    """
    def evaluate(
        self, inputs: typing.Sequence[typing.Sequence[builtins.float]]
    ) -> builtins.list[Tensor]:
        r"""
        Evaluate the tensor expression for multiple real-valued parameter inputs.

        # Args:
            inputs: List of parameter value lists, where each inner list contains
                    numerical values for all parameters in the same order as specified
                    when creating the evaluator

        # Returns:
            List of evaluated tensors, one for each input parameter set

        # Raises:
            ValueError: If the evaluator contains complex coefficients

        # Examples:
        ```python
        # Evaluate for two different parameter sets
        results = evaluator.evaluate([
            [1.0, 2.0],  # x=1.0, y=2.0
            [3.0, 4.0]   # x=3.0, y=4.0
        ])
        ```
        """
    def evaluate_complex(
        self, inputs: typing.Sequence[typing.Sequence[builtins.complex]]
    ) -> builtins.list[Tensor]:
        r"""
        Evaluate the expression for multiple inputs and return the results.
        """
    def compile(
        self,
        function_name: builtins.str,
        filename: builtins.str,
        library_name: builtins.str,
        inline_asm: builtins.str = "default",
        optimization_level: builtins.int = 3,
        compiler_path: typing.Optional[builtins.str] = None,
        custom_header: typing.Optional[builtins.str] = None,
    ) -> CompiledTensorEvaluator:
        r"""
        Compile the evaluator to a shared library using C++ for maximum performance.

        Generates optimized C++ code with optional inline assembly and compiles it
        into a shared library that can be loaded for extremely fast evaluation.

        # Args:
            function_name: Name for the generated C++ function
            filename: Path for the generated C++ source file
            library_name: Name for the compiled shared library
            inline_asm: Type of inline assembly optimization:
                         - "default": Platform-appropriate assembly
                         - "x64": x86-64 specific optimizations
                         - "aarch64": ARM64 specific optimizations
                         - "none": No inline assembly
            optimization_level: Compiler optimization level 0-3 (default: 3)
            compiler_path: Path to specific C++ compiler (default: system default)
            custom_header: Additional C++ header code to include

        # Returns:
            A CompiledTensorEvaluator for maximum performance evaluation

        # Examples:
        ```python
        from symbolica import S
        from symbolica.community.spenso import (
            Tensor,
            TensorIndices,
            Representation as R,
        )
        # Create symbolic tensor
        x, y = S("x", "y")
        structure = TensorIndices(R.euc(2)(1))
        tensor = Tensor.dense(structure, [x * y, x + y])
        # Create evaluator
        evaluator = tensor.evaluator(
            constants={}, funs={}, params=[x, y], iterations=50
        )
        inputs = [[1.0, 2.0], [3.0, 4.0]]
        # Use evaluator
        results = evaluator.evaluate_complex(inputs)
        print(results)
        compiled = evaluator.compile(
            function_name="fast_eval",
            filename="tensor_eval.cpp",
            library_name="tensor_lib",
            optimization_level=3,
        )
        # Use compiled evaluator
        results = compiled.evaluate_complex(inputs)
        ```
        """

class TensorIndices:
    r"""
    A tensor structure with abstract indices for symbolic tensor operations.

    TensorIndices represents the index structure of tensors with named abstract indices
    that can be contracted, manipulated symbolically, and converted to expressions.
    It maintains both the representation structure and index assignments.

    # Examples:
    ```python
    from symbolica.community.spenso import TensorIndices, Slot, Representation, TensorName

    # Create from slots
    rep = Representation.euc(3)
    mu = rep('mu')
    nu = rep('nu')
    indices = TensorIndices(mu, nu)

    # Create with name
    T = TensorName("T")
    named_indices = T(mu, nu)  # Creates TensorIndices with name "T"

    # Access elements
    print(len(indices))       # Number of elements
    print(indices[0])         # First element's coordinates
    print(indices[1, 2])      # Flat index for coordinates [1, 2]

    # Convert to expression
    expr = named_indices.to_expression()  # Symbolic tensor expression
    ```
    """
    def __new__(
        cls,
        *slots: Slot | Expression | int | str | float | complex,
        name: TensorName | builtins.str | Expression | None = None,
    ) -> TensorStructure:
        r"""
        Create tensor structure from slots and optional arguments.

        # Args:
            *additional_args: Mixed arguments:
                - Slot objects: Define the tensor representation structure
                - Expressions: Additional non-indexed arguments
            name: Optional tensor name to assign to the structure

        # Returns:
            A new TensorStructure object

        # Examples:
        ```python
        from symbolica import S
        from symbolica.community.spenso import TensorStructure, Representation, TensorName

        # Create from representations
        rep = Representation.euc(3)
        structure = TensorStructure(rep, rep)  # 3x3 tensor

        # With additional arguments
        x = S('x')
        structure_with_args = TensorStructure(rep, rep, x)

        # With name
        T = TensorName("T")
        named_structure = TensorStructure(rep, rep, name=T)
        ```
        """
    @typing.overload
    def __getitem__(
        self, item: builtins.slice
    ) -> builtins.list[Expression | builtins.complex | float]:
        r"""
        Get expanded indices at the specified range of flatend indices.

        # Args:
            item: Index specification:
                - slice: Slice object defining the range of indices

        # Returns:
            The tensor element(s) at the specified index:
                - list of expanded indices (list of indices themselves)
        """
    @typing.overload
    def __getitem__(
        self, item: typing.Sequence[builtins.int]
    ) -> Expression | builtins.complex | float:
        r"""
        Get flattened index associated to this expanded index

        # Args:
            item: Index specification:
                - List[int]: Multi-dimensional index coordinates

        # Returns:
            the flat index: int
        """
    @typing.overload
    def __getitem__(
        self, item: builtins.int
    ) -> Expression | builtins.complex | float:
        r"""
        Get expanded index associated to this flat index

        # Args:
            item: Index specification:
                - int: Flat index into the tensor

        # Returns:
            List[int]: Multi-dimensional index coordinates
        """
    def set_name(self, name: TensorName | builtins.str | Expression) -> None:
        r"""
        Set the tensor name for this structure.

        # Args:
            name: The tensor name to assign

        # Examples:
        ```python
        from symbolica.community.spenso import TensorStructure, TensorName, Representation

        rep = Representation.euc(3)
        structure = TensorStructure(rep, rep)

        T = TensorName("T")
        structure.set_name(T)
        ```
        """
    def get_name(self) -> typing.Optional[TensorName]:
        r"""
        Get the tensor name of this structure.

        # Returns:
            The tensor name if set, None otherwise

        # Examples:
        ```python
        # For a named tensor structure
        name = structure.get_name()  # Returns TensorName object or None
        ```
        """
    def __repr__(self) -> builtins.str: ...
    def __str__(self) -> builtins.str: ...
    def to_expression(self) -> Expression:
        r"""
        Convert the tensor indices to a symbolic expression.

        Creates a symbolic representation of the tensor with its indices that can be
        used in algebraic manipulations and pattern matching.

        # Returns:
            A symbolic Expression representing this indexed tensor

        # Raises:
            RuntimeError: If the tensor structure has no name

        # Examples:
        ```python
        from symbolica.community.spenso import TensorName, Representation

        T = TensorName("T")
        rep = Representation.euc(3)
        mu = rep('mu')
        nu = rep('nu')
        indices = T(mu, nu)

        expr = indices.to_expression()  # T(mu, nu) as symbolic expression
        print(expr)  # Can be used in symbolic computations
        ```
        """
    def __len__(self) -> builtins.int: ...
    def __add__(
        self,
        rhs: Expression
        | int
        | str
        | float
        | complex
        | TensorIndices
        | Expression,
    ) -> Expression:
        r"""
        Add this expression to `other`, returning the result.
        """
    def __radd__(
        self,
        rhs: Expression
        | int
        | str
        | float
        | complex
        | TensorIndices
        | Expression,
    ) -> Expression:
        r"""
        Add this expression to `other`, returning the result.
        """
    def __sub__(
        self,
        rhs: Expression
        | int
        | str
        | float
        | complex
        | TensorIndices
        | Expression,
    ) -> Expression:
        r"""
        Subtract `other` from this expression, returning the result.
        """
    def __rsub__(
        self,
        rhs: Expression
        | int
        | str
        | float
        | complex
        | TensorIndices
        | Expression,
    ) -> Expression:
        r"""
        Subtract this expression from `other`, returning the result.
        """
    def __mul__(
        self,
        rhs: Expression
        | int
        | str
        | float
        | complex
        | TensorIndices
        | Expression,
    ) -> Expression:
        r"""
        Add this expression to `other`, returning the result.
        """
    def __rmul__(
        self,
        rhs: Expression
        | int
        | str
        | float
        | complex
        | TensorIndices
        | Expression,
    ) -> Expression:
        r"""
        Add this expression to `other`, returning the result.
        """

class TensorLibrary:
    r"""
    A library for registering and managing tensor templates and structures.

    The TensorLibrary provides a centralized registry for tensor definitions that can be
    reused across tensor networks and expressions. It manages tensor structures with their
    associated names and can resolve symbolic references to registered tensors.

    # Examples:
    ```python
    import symbolica
    from symbolica.community.spenso import (
        TensorLibrary,
        LibraryTensor,
        TensorStructure,
    )
    from symbolica.community.spenso import Representation
    # Create a new library
    lib = TensorLibrary()
    # Register a tensor structure
    rep = Representation.euc(3)  # Color fundamental representation
    name = symbolica.S("my_tensor")
    structure = TensorStructure(rep, rep, name=name)
    tensor = LibraryTensor.dense(
        structure, [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0]
    )
    lib.register(tensor)
    # Access registered tensor structure
    tensor_ref = lib[name]
    ```
    """
    def __new__(cls) -> TensorLibrary:
        r"""
        Create a new empty tensor library.

        Initializes an empty library ready for registering tensor structures.
        The library automatically manages internal tensor IDs.

        # Returns:
            A new empty TensorLibrary instance

        # Examples:
        ```python
        from symbolica.community.spenso import TensorLibrary

        # Create new library
        lib = TensorLibrary()
        ```
        """
    def register(self, tensor: Tensor | LibraryTensor) -> None:
        r"""
        Register a tensor in the library.

        Adds a tensor template to the library that can be referenced by name
        in tensor networks and symbolic expressions. The tensor must have a name
        set in its structure.

        # Args:
            tensor: The tensor to register - can be a LibraryTensor or regular Tensor

        # Examples:
        ```python
        import symbolica
        from symbolica.community.spenso import (
            TensorLibrary,
            LibraryTensor,
            TensorStructure,
        )
        from symbolica.community.spenso import Representation
        # Create a new library
        lib = TensorLibrary()
        # Register a tensor structure
        rep = Representation.euc(3)  # Color fundamental representation
        name = symbolica.S("my_tensor")
        structure = TensorStructure(rep, rep, name=name)
        tensor = LibraryTensor.dense(
            structure, [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0]
        )
        lib.register(tensor)
        # Access registered tensor structure
        tensor_ref = lib[name]
        ```
        """
    def __getitem__(
        self, key: Expression | int | str | float | complex | builtins.str
    ) -> TensorStructure:
        r"""
        Retrieve a registered tensor structure by name.

        Looks up a previously registered tensor by its name and returns
        a reference structure that can be used to create new tensor instances.

        # Args:
            key: The tensor name - can be a string or symbolic expression

        # Returns:
            A TensorStructure representing the registered tensor template

        # Raises:
            Error: If the tensor name is not found in the library

        # Examples:
        ```python
        # After registering a tensor named "T"
        structure = lib["T"]  # Get the structure template
        ```
        """
    @staticmethod
    def hep_lib() -> TensorLibrary:
        r"""
        Create a library pre-loaded with High Energy Physics tensor definitions.

        Returns a library containing standard HEP tensors such as gamma matrices,
        color generators, metric tensors, and other commonly used structures in
        particle physics calculations.

        # Returns:
            A TensorLibrary pre-populated with HEP tensor definitions

        # Examples:
        ```python
        import symbolica
        from symbolica.community.spenso import TensorLibrary, TensorName
        # Get HEP library with standard tensors
        hep_lib = TensorLibrary.hep_lib()
        # Access standard tensors like gamma matrices
        gamma_structure = hep_lib[symbolica.S("spenso::gamma")]
        print(gamma_structure)
        print(gamma_structure(7, 3, 4))
        ```
        """

class TensorName:
    r"""
    A symbolic name for tensor functions and structures.

    TensorName represents named tensor functions that can be called with indices and arguments
    to create tensor structures. Names can have various mathematical properties like symmetry,
    antisymmetry, and custom normalization or printing behavior.

    # Examples:
    ```python
    from symbolica.community.spenso import TensorName, Slot, Representation

    # Create a simple tensor name
    T = TensorName("T")

    # Create tensor with symmetry properties
    symmetric_T = TensorName("S", is_symmetric=True)
    antisymmetric_T = TensorName("A", is_antisymmetric=True)

    # Use with slots to create indexed structures
    rep = Representation.cof(3)
    mu = rep('mu')
    nu = rep('nu')
    tensor_structure = T(mu, nu)  # Creates TensorIndices
    ```
    """

    g: TensorName
    r"""
    Predefined metric tensor name.

    # Returns:
        TensorName for the metric tensor 'g'
    """
    flat: TensorName
    r"""
    Predefined musical isomorphis tensor name. This enables dualizing  self dual indices.

    # Returns:
        TensorName for the flat musical isomorphism
    """
    gamma: TensorName
    r"""
    Predefined gamma matrix name.

    # Returns:
        TensorName for Dirac gamma matrices
    """
    gamma5: TensorName
    r"""
    Predefined gamma5 matrix name.

    # Returns:
        TensorName for the gamma5 matrix
    """
    projm: TensorName
    r"""
    Predefined left chiral projector name.

    # Returns:
        TensorName for the left projector P_L
    """
    projp: TensorName
    r"""
    Predefined right chiral projector name.

    # Returns:
        TensorName for the right projector P_R
    """
    sigma: TensorName
    r"""
    Predefined sigma matrix name.

    # Returns:
        TensorName for Pauli sigma matrices
    """
    f: TensorName
    r"""
    Predefined color structure constant name.

    # Returns:
        TensorName for SU(N) structure constants f^abc
    """
    t: TensorName
    r"""
    Predefined color generator name.

    # Returns:
        TensorName for SU(N) generators T^a
    """
    @typing.overload
    def __call__(
        self, *args: Slot | Expression | int | str | float | complex
    ) -> TensorIndices:
        r"""
        Call the tensor name with arguments to create tensor structures.

        Accepts a mix of slots and symbolic expressions (for additional arguments)

        # Args:
            *args:
                - Slot objects: Create indexed tensor structure (TensorIndices)
                - Expressions: Additional non-tensorial arguments

        # Returns:
           TensorIndices

        # Examples:
        ```python
        from symbolica.community.spenso import TensorName, Slot, Representation
        import symbolica as sp

        T = TensorName("T")
        rep = Representation.euc(3)
        # With slots (creates TensorIndices)
        mu = rep("mu")
        nu = rep("nu")
        indexed_tensor = T(mu, nu)
        ```
        """
    @typing.overload
    def __call__(self, *args: Representation | Expression) -> TensorStructure:
        r"""
        Call the tensor name with arguments to create a TensorStructure.

        Accepts a mix of representations and symbolic expressions (for additional arguments).

        # Args:
            *args: Mixed arguments:
                - Representation objects: Create indexless structure (TensorStructure)
                - Expressions: Additional non-tensorial arguments

        # Returns:
            TensorStructure

        # Examples:
        ```python
        from symbolica.community.spenso import TensorName, Slot, Representation
        import symbolica as sp

        T = TensorName("T")
        rep = Representation.euc(3)
        structure_tensor = T(rep, rep)
        ```
        """
    def __new__(
        cls,
        name: builtins.str,
        is_symmetric: typing.Optional[builtins.bool] = None,
        is_antisymmetric: typing.Optional[builtins.bool] = None,
        is_cyclesymmetric: typing.Optional[builtins.bool] = None,
        is_linear: typing.Optional[builtins.bool] = None,
        custom_normalization: typing.Optional[Transformer] = None,
    ) -> TensorName:
        r"""
        Create a new tensor name with optional mathematical properties.

        # Args:
            name: The string name for the tensor function
            is_symmetric: If True, tensor is symmetric under index permutation
            is_antisymmetric: If True, tensor is antisymmetric under index permutation
            is_cyclesymmetric: If True, tensor is symmetric under cyclic permutations
            is_linear: If True, tensor is linear in its arguments
            custom_normalization: Custom normalization function (advanced)
            custom_print: Custom printing function (advanced)

        # Returns:
            A new TensorName with the specified properties

        # Examples:
        ```python
        from symbolica.community.spenso import TensorName

        # Basic tensor name
        T = TensorName("T")

        # Symmetric tensor (like metric)
        g = TensorName("g", is_symmetric=True)

        # Antisymmetric tensor (like field strength)
        F = TensorName("F", is_antisymmetric=True)

        # Linear operator
        D = TensorName("D", is_linear=True)
        ```
        """
    def __repr__(self) -> builtins.str: ...
    def __str__(self) -> builtins.str: ...
    def to_expression(self) -> Expression:
        r"""
        Convert the tensor name to a symbolic expression.

        # Returns:
            A symbolic Expression representing this tensor name

        # Examples:
        ```python
        T = TensorName("T")
        expr = T.to_expression()  # Symbol T as expression
        ```
        """

class TensorNetwork:
    r"""
    A tensor network representing computational graphs of tensor operations.

    A tensor network is a graph-based representation of tensor computations where:
    - Nodes represent tensors and operations
    - Edges represent tensor contractions and data flow
    - The network can be optimized and executed to compute results

    Tensor networks are particularly useful for:
    - Symbolic manipulation of complex tensor expressions
    - Optimization of tensor contraction orders
    - Efficient evaluation of large tensor computations
    - Physics calculations involving many-body systems

    # Examples:
    ```python
    import symbolica as sp
    from symbolica.community.spenso import TensorNetwork, Tensor, TensorIndices

    # Create from an expression
    x = sp.symbol('x')
    expr = x * sp.symbol('T')(sp.symbol('mu'), sp.symbol('nu'))
    network = TensorNetwork(expr)

    # Execute the network
    network.execute()
    result = network.result_tensor()
    ```
    """
    def __new__(
        cls,
        expr: Expression
        | int
        | str
        | float
        | complex
        | TensorIndices
        | Expression,
        library: typing.Optional[TensorLibrary] = None,
    ) -> TensorNetwork:
        r"""
        Create a tensor network by parsing an arithmetic expression.

        Parses symbolic expressions containing tensor operations and converts them
        into an optimizable computational graph representation.

        # Args:
            expr: The arithmetic expression or tensor structure to parse
            library: Optional tensor library for resolving named tensor references

        # Returns:
            A new TensorNetwork representing the parsed expression
        """
    @staticmethod
    def one() -> TensorNetwork:
        r"""
        Create a tensor network representing the scalar value 1.

        # Returns:
            A TensorNetwork containing only the scalar 1

        # Examples:
        ```python
        from symbolica.community.spenso import TensorNetwork

        one_net = TensorNetwork.one()
        print(one_net.result_scalar())  # "1"
        ```
        """
    @staticmethod
    def zero() -> TensorNetwork:
        r"""
        Create a tensor network representing the scalar value 0.

        # Returns:
            A TensorNetwork containing only the scalar 0

        # Examples:
        ```python
        from symbolica.community.spenso import TensorNetwork

        zero_net = TensorNetwork.zero()
        print(zero_net.result_scalar())  # "0"
        ```
        """
    def replace(
        self,
        pattern: Expression | int | str | float | complex,
        rhs: Expression
        | int
        | str
        | float
        | complex
        | HeldExpression
        | typing.Callable[[dict[Expression, Expression]], Expression]
        | int
        | float
        | complex
        | decimal.Decimal,
        _cond: typing.Optional[PatternRestriction | Condition] = None,
        non_greedy_wildcards: typing.Optional[
            typing.Sequence[Expression]
        ] = None,
        level_range: typing.Optional[
            tuple[builtins.int, typing.Optional[builtins.int]]
        ] = None,
        level_is_tree_depth: typing.Optional[builtins.bool] = None,
        allow_new_wildcards_on_rhs: typing.Optional[builtins.bool] = None,
        rhs_cache_size: typing.Optional[builtins.int] = None,
        repeat: typing.Optional[builtins.bool] = None,
    ) -> TensorNetwork:
        r"""
        Replace patterns in the tensor network using symbolic pattern matching.

        Applies pattern-based transformations to the network structure, allowing for
        symbolic simplifications, substitutions, and algebraic manipulations.

        # Args:
            pattern: The symbolic pattern to match against
            rhs: The replacement expression or pattern
            non_greedy_wildcards: List of wildcard symbols to match non-greedily
            level_range: Tuple specifying depth range for pattern matching
            level_is_tree_depth: Whether level refers to tree depth or expression depth
            allow_new_wildcards_on_rhs: Allow new wildcards in replacement pattern
            rhs_cache_size: Size of cache for replacement pattern compilation
            repeat: Whether to repeatedly apply the replacement until no more matches

        # Returns:
            A new TensorNetwork with the replacements applied
        """
    def evaluate(
        self,
        constants: typing.Mapping[Expression, builtins.float],
        functions: typing.Mapping[Expression, typing.Any],
    ) -> TensorNetwork:
        r"""
        Evaluate symbolic expressions in the network with numerical values.

        Substitutes symbolic constants and functions with numerical values,
        converting symbolic parts of the network to concrete numerical tensors.

        # Args:
            constants: Dict mapping symbolic expressions to their numerical values
            functions: Dict mapping function symbols to Python callable objects

        # Returns:
            A new TensorNetwork with symbolic expressions evaluated
        """
    def execute(
        self,
        library: typing.Optional[TensorLibrary] = None,
        n_steps: typing.Optional[builtins.int] = None,
        mode: ExecutionMode = ...,
    ) -> None:
        r"""
        Execute the tensor network to perform tensor contractions and simplifications.

        Processes the computational graph by executing tensor operations such as
        contractions, additions, and multiplications. The execution can be controlled
        by mode and step limits.

        # Args:
            library: Optional tensor library for resolving tensor operations
            n_steps: Maximum number of execution steps (None for complete execution)
            mode: Execution strategy:
                - ExecutionMode.All: Execute all possible operations (default)
                - ExecutionMode.Scalar: Only execute scalar operations
                - ExecutionMode.Single: Execute one operation at a time

        # Examples:
        ```python
        from symbolica.community.spenso import TensorNetwork, ExecutionMode, TensorLibrary

        # Create and execute network
        network = TensorNetwork(some_expression)
        network.execute()  # Complete execution

        # Partial execution
        network.execute(n_steps=5)  # Execute up to 5 steps

        # Controlled execution
        network.execute(mode=ExecutionMode.Scalar)  # Only scalar operations

        # With library context
        lib = TensorLibrary.hep_lib()
        network.execute(library=lib)
        ```
        """
    def result_tensor(
        self, library: typing.Optional[TensorLibrary] = None
    ) -> Tensor:
        r"""
        Extract the final tensor result from the executed network.

        After network execution, retrieves the computed tensor result. The network
        should be executed before calling this method.

        # Args:
            library: Optional tensor library for resolving tensor structures

        # Returns:
            The computed tensor result

        # Raises:
            RuntimeError: If the network execution resulted in an error

        # Examples:
        ```python
        from symbolica.community.spenso import TensorNetwork, TensorLibrary

        # Execute network and get result
        network = TensorNetwork(tensor_expression)
        network.execute()
        result = network.result_tensor()

        # With library context
        lib = TensorLibrary.hep_lib()
        result_with_lib = network.result_tensor(library=lib)
        ```
        """
    def result_scalar(self) -> Expression:
        r"""
        Extract the final scalar result from the executed network.

        For networks that evaluate to scalar expressions, retrieves the computed
        scalar value. The network should be executed before calling this method.

        # Returns:
            The computed scalar expression

        # Raises:
            RuntimeError: If the network execution resulted in an error

        # Examples:
        ```python
        from symbolica.community.spenso import TensorNetwork

        # Execute network that results in scalar
        network = TensorNetwork(scalar_expression)
        network.execute()
        scalar_result = network.result_scalar()
        print(f"Result: {scalar_result}")
        ```
        """
    def __str__(self) -> builtins.str:
        r"""
        Return a string representation of the network structure.

        Generates a DOT format representation of the computational graph that can be
        visualized using graphviz or similar tools.

        # Returns:
            A DOT format string representing the network structure
        """
    def __add__(
        self,
        rhs: Expression
        | int
        | str
        | float
        | complex
        | TensorIndices
        | Expression
        | TensorNetwork
        | Tensor,
    ) -> TensorNetwork:
        r"""
        Add two tensor networks element-wise.

        # Args:
            rhs: The tensor network to add (right-hand side)

        # Returns:
            A new TensorNetwork representing the sum

        # Examples:
        ```python
        net1 = TensorNetwork(expr1)
        net2 = TensorNetwork(expr2)
        sum_net = net1 + net2
        ```
        """
    def __radd__(
        self,
        rhs: Expression
        | int
        | str
        | float
        | complex
        | TensorIndices
        | Expression
        | TensorNetwork
        | Tensor,
    ) -> TensorNetwork:
        r"""
        Add two tensor networks element-wise (right-hand addition).
        """
    def __sub__(
        self,
        rhs: Expression
        | int
        | str
        | float
        | complex
        | TensorIndices
        | Expression
        | TensorNetwork
        | Tensor,
    ) -> TensorNetwork:
        r"""
        Subtract one tensor network from another element-wise.

        # Args:
            rhs: The tensor network to subtract (right-hand side)

        # Returns:
            A new TensorNetwork representing the difference

        # Examples:
        ```python
        net1 = TensorNetwork(expr1)
        net2 = TensorNetwork(expr2)
        diff_net = net1 - net2
        ```
        """
    def __rsub__(
        self,
        rhs: Expression
        | int
        | str
        | float
        | complex
        | TensorIndices
        | Expression
        | TensorNetwork
        | Tensor,
    ) -> TensorNetwork:
        r"""
        Subtract one tensor network from another (right-hand subtraction).
        """
    def __mul__(
        self,
        rhs: Expression
        | int
        | str
        | float
        | complex
        | TensorIndices
        | Expression
        | TensorNetwork
        | Tensor,
    ) -> TensorNetwork:
        r"""
        Multiply two tensor networks.

        # Args:
            rhs: The tensor network to multiply with (right-hand side)

        # Returns:
            A new TensorNetwork representing the product

        # Examples:
        ```python
        net1 = TensorNetwork(expr1)
        net2 = TensorNetwork(expr2)
        product_net = net1 * net2
        ```
        """
    def __rmul__(
        self,
        rhs: Expression
        | int
        | str
        | float
        | complex
        | TensorIndices
        | Expression
        | TensorNetwork
        | Tensor,
    ) -> TensorNetwork:
        r"""
        Multiply two tensor networks (right-hand multiplication).
        """

class TensorStructure:
    r"""
    A tensor structure without abstract indices, defined purely by representations.

    TensorStructure represents the shape and representation structure of tensors
    without specific index assignments. It's used for defining tensor templates
    in libraries and for creating indexless tensor computations.

    # Examples:
    ```python
    from symbolica.community.spenso import TensorStructure, Representation, TensorName

    # Create from representations
    rep = Representation.euc(3)  # Color fundamental
    structure = TensorStructure(rep, rep)  # 3x3 matrix structure

    # With name for library registration
    T = TensorName("T")
    named_structure = TensorStructure(rep, rep, name=T)

    # Use to create indexed tensor
    indices = structure.index('mu', 'nu')  # Assign specific indices

    # Create symbolic expression
    expr = structure.symbolic('a', 'b')  # T(a, b)
    ```
    """
    def __new__(
        cls,
        *reps_and_additional_args: Representation
        | Expression
        | int
        | str
        | float
        | complex,
        name: TensorName | builtins.str | Expression | None = None,
    ) -> TensorStructure:
        r"""
        Constuct a new TensorStructure with the given representations.
        """
    @typing.overload
    def __getitem__(
        self, item: builtins.slice
    ) -> builtins.list[Expression | builtins.complex | float]:
        r"""
        Get expanded indices at the specified range of flatend indices.

        # Args:
            item: Index specification:
                - slice: Slice object defining the range of indices

        # Returns:
            The tensor element(s) at the specified index:
                - list of expanded indices (list of indices themselves)
        """
    @typing.overload
    def __getitem__(
        self, item: typing.Sequence[builtins.int]
    ) -> Expression | builtins.complex | float:
        r"""
        Get flattened index associated to this expanded index

        # Args:
            item: Index specification:
                - List[int]: Multi-dimensional index coordinates

        # Returns:
            the flat index: int
        """
    @typing.overload
    def __getitem__(
        self, item: builtins.int
    ) -> Expression | builtins.complex | float:
        r"""
        Get expanded index associated to this flat index

        # Args:
            item: Index specification:
                - int: Flat index into the tensor

        # Returns:
            List[int]: Multi-dimensional index coordinates
        """
    def __call__(
        self,
        *args: builtins.int | Expression | str,
        extra_args: typing.Sequence[
            Expression | int | str | float | complex
        ] = [],
    ) -> Expression:
        r"""
        Convenience method for creating symbolic expressions.

        This is a shorthand for calling `symbolic(*args, extra_args=extra_args)`.
        Creates a symbolic Expression representing this tensor structure.

        # Args:
            *args: Positional arguments (indices and additional args)
            extra_args: Optional list of additional non-tensorial arguments

        # Returns:
            A symbolic Expression representing the tensor

        # Examples:
        ```python
        structure = TensorStructure(rep, rep, name="T")
        expr = structure('mu', 'nu')  # Same as structure.symbolic('mu', 'nu')
        ```
        """
    def symbolic(
        self,
        *args: builtins.int | Expression | str,
        extra_args: typing.Sequence[
            Expression | int | str | float | complex
        ] = [],
    ) -> Expression:
        r"""
        Create a symbolic expression representing this tensor structure.

        Builds a symbolic tensor expression with the specified indices. Arguments can be
        separated using a semicolon (';') to distinguish between additional arguments
        and tensor indices.

        # Args:
            *args: Positional arguments, can include:
                - int, str, Symbol, Expression: Tensor indices
                - ';': Separator between additional args and indices
            extra_args: Optional list of additional non-tensorial arguments

        # Returns:
            A symbolic Expression representing the tensor with indices

        # Raises:
            ValueError: If index count doesn't match structure order
            TypeError: If arguments have unexpected types
            RuntimeError: If the structure has no name

        # Examples:
        ```python
        import symbolica as sp
        from symbolica.community.spenso import TensorStructure, Representation, TensorName

        rep = Representation.euc(3)
        T = TensorName("T")
        structure = TensorStructure([rep, rep], name=T)

        # Basic usage
        expr = structure.symbolic('mu', 'nu')  # T(mu, nu)

        # With additional arguments
        x = sp.S('x')
        expr = structure.symbolic(x, ';', 'mu', 'nu')  # T(x; mu, nu)

        # Using extra_args parameter
        expr = structure.symbolic('mu', 'nu', extra_args=[x])  # T(x; mu, nu)
        ```
        """
    def index(
        self,
        *args: builtins.int | Expression | str,
        extra_args: typing.Sequence[Expression] = [],
        cook_indices: builtins.bool = False,
    ) -> TensorIndices:
        r"""
        Create an indexed tensor (TensorIndices) from this structure.

        Converts this structure template into a concrete indexed tensor by assigning
        specific abstract indices to each representation slot.

        # Args:
            *args: Positional arguments:
                - Indices (int, str, Symbol, Expression)
                - ';': Separator between additional args and indices
            extra_args: Optional list of additional non-tensorial arguments
            cook_indices: If True, attempt to convert expressions to valid indices

        # Returns:
            A TensorIndices object with concrete index assignments

        # Raises:
            ValueError: If index count doesn't match or conversion fails
            TypeError: If arguments have unexpected types

        # Examples:
        ```python
        import symbolica as sp
        from symbolica.community.spenso import TensorStructure, Representation, TensorName

        rep = Representation.cof(3)
        T = TensorName("T")
        structure = TensorStructure([rep, rep], name=T)

        # Create indexed tensor
        indices = structure.index('mu', 'nu')  # T with indices mu, nu

        # With additional arguments
        x = sp.S('x')
        indices = structure.index(x, ';', 'mu', 'nu')  # T(x; mu, nu)
        ```
        """
    def set_name(
        self, name: TensorName | builtins.str | Expression
    ) -> None: ...
    def get_name(self) -> typing.Optional[TensorName]: ...
    def __repr__(self) -> builtins.str: ...
    def __str__(self) -> builtins.str: ...
    def __len__(self) -> builtins.int: ...

class ExecutionMode(Enum):
    r"""
    Execution modes for tensor network evaluation.

    Controls how the tensor network execution engine processes the computational graph:

    # Variants:
        Single: Execute one contraction at a time, useful for debugging
        Scalar: Only contract scalar operations, leaving tensor structure intact
        All: Execute all possible contractions for complete evaluation
    """

    Single = ...
    Scalar = ...
    All = ...

class TensorNamespace(Enum):
    r"""
    Enumeration for different tensor namespaces in physics.

    Provides categorization for different types of tensor operations and structures
    commonly used in theoretical physics calculations.

    # Variants:
        Weyl: Tensors related to Weyl spinors and chiral representations
        Algebra: Tensors related to algebraic structures and Lie algebras
    """

    Weyl = ...
    Algebra = ...
